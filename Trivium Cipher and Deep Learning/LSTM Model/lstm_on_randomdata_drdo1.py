# -*- coding: utf-8 -*-
"""LSTM_on_randomData_DRDO1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UpcjLUAk0OA840l1bHcNDIYNz_moaGss
"""

import pandas as pd
import pandas as pd
import numpy as np
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
import tensorflow as tf

# upload data file from local computer

from google.colab import files
uploaded = files.upload()

import io
# features = io.BytesIO(uploaded['simon_features-.csv']) 
# labels = io.BytesIO(uploaded['simon_labels.csv']) 
data = io.BytesIO(uploaded['simon_data.csv'])

data = pd.read_csv(data)
print(data.head())

input_features = data.iloc[:,:16].values
# print(input_features.head())
output = data.iloc[:,23].values

# print(output.head())

# features and labels
X = input_features
Y = output
# print(X.head())
# print(Y.head())

from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2, random_state = 101)

x_train = tf.keras.utils.normalize(x_train, axis = 1)
x_test = tf.keras.utils.normalize(x_test, axis = 1)

x_train=x_train.reshape(len(x_train),1,16)
x_test=x_test.reshape(len(x_test),1,16)

print(x_train[0:3])

print(y_test.shape)
print(y_train.shape)

import keras 
from keras.models import Sequential 
from keras.layers import Dense, Flatten
from keras.layers import Embedding

model = Sequential()

model.add(LSTM(300,input_shape = (None,16),activation='relu', return_sequences = False))
# model.add(Dense(50, activation='relu'))
# model.add(Dense(100, activation='relu'))
model.add(Dense(output_dim=1, activation='sigmoid'))
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

model.fit(x_train,y_train,epochs=5)

y_pred = model.predict(x_test)

val_loss , val_acc = model.evaluate(x_test,y_test)

print(val_loss, val_acc)

for i in range(0,20):
  print(y_test[i]," ",y_pred[i])

y_pred = y_pred > 0.5
from sklearn.metrics import confusion_matrix

print(confusion_matrix(y_test, y_pred))

